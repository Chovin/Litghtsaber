function t(t){if(!Number.isSafeInteger(t)||t<0)throw Error("positive integer expected, got "+t)}function e(t,...e){if(!((r=t)instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name))throw Error("Uint8Array expected");var r;if(e.length>0&&!e.includes(t.length))throw Error("Uint8Array expected of length "+e+", got length="+t.length)}function r(t,e=!0){if(t.destroyed)throw Error("Hash instance has been destroyed");if(e&&t.finished)throw Error("Hash#digest() has already been called")}const n="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function o(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function i(t,e){return t<<32-e|t>>>e}function s(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),e(t),t}"function"==typeof Uint8Array.from([]).toHex&&Uint8Array.fromHex;class a{clone(){return this._cloneInto()}}function c(t){const e=e=>t().update(s(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function f(t=32){if(n&&"function"==typeof n.getRandomValues)return n.getRandomValues(new Uint8Array(t));if(n&&"function"==typeof n.randomBytes)return Uint8Array.from(n.randomBytes(t));throw Error("crypto.getRandomValues must be defined")}function u(t,e,r){return t&e^t&r^e&r}class l extends a{constructor(t,e,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(t),this.view=o(this.buffer)}update(t){r(this);const{view:e,buffer:n,blockLen:i}=this,a=(t=s(t)).length;for(let r=0;r<a;){const s=Math.min(i-this.pos,a-r);if(s!==i)n.set(t.subarray(r,r+s),this.pos),this.pos+=s,r+=s,this.pos===i&&(this.process(e,0),this.pos=0);else{const e=o(t);for(;i<=a-r;r+=i)this.process(e,r)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){r(this),function(t,r){e(t);const n=r.outputLen;if(t.length<n)throw Error("digestInto() expects output buffer of length at least "+n)}(t,this),this.finished=!0;const{buffer:n,view:i,blockLen:s,isLE:a}=this;let{pos:c}=this;n[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>s-c&&(this.process(i,0),c=0);for(let t=c;t<s;t++)n[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?4:0,f=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+f,a,n)}(i,s-8,BigInt(8*this.length),a),this.process(i,0);const f=o(t),u=this.outputLen;if(u%4)throw Error("_sha2: outputLen should be aligned to 32bit");const l=u/4,d=this.get();if(l>d.length)throw Error("_sha2: outputLen bigger than state");for(let t=0;t<l;t++)f.setUint32(4*t,d[t],a)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return t.length=n,t.pos=s,t.finished=o,t.destroyed=i,n%e&&t.buffer.set(r),t}}const d=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),h=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),p=new Uint32Array(64);class g extends l{constructor(t=32){super(64,t,8,!1),this.A=0|h[0],this.B=0|h[1],this.C=0|h[2],this.D=0|h[3],this.E=0|h[4],this.F=0|h[5],this.G=0|h[6],this.H=0|h[7]}get(){const{A:t,B:e,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[t,e,r,n,o,i,s,a]}set(t,e,r,n,o,i,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)p[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=p[t-15],r=p[t-2],n=i(e,7)^i(e,18)^e>>>3,o=i(r,17)^i(r,19)^r>>>10;p[t]=o+p[t-7]+n+p[t-16]|0}let{A:r,B:n,C:o,D:s,E:a,F:c,G:f,H:l}=this;for(let t=0;t<64;t++){const e=l+(i(a,6)^i(a,11)^i(a,25))+((h=a)&c^~h&f)+d[t]+p[t]|0,g=(i(r,2)^i(r,13)^i(r,22))+u(r,n,o)|0;l=f,f=c,c=a,a=s+e|0,s=o,o=n,n=r,r=e+g|0}var h;r=r+this.A|0,n=n+this.B|0,o=o+this.C|0,s=s+this.D|0,a=a+this.E|0,c=c+this.F|0,f=f+this.G|0,l=l+this.H|0,this.set(r,n,o,s,a,c,f,l)}roundClean(){p.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const y=c((()=>new g));class m extends a{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,function(e){if("function"!=typeof e||"function"!=typeof e.create)throw Error("Hash should be wrapped by utils.wrapConstructor");t(e.outputLen),t(e.blockLen)}(e);const n=s(r);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(n.length>o?e.create().update(n).digest():n);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=e.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),i.fill(0)}update(t){return r(this),this.iHash.update(t),this}digestInto(t){r(this),e(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=n,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const w=(t,e,r)=>new m(t,e).update(r).digest();w.create=(t,e)=>new m(t,e);const b=BigInt(0),E=BigInt(1);function v(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function B(t){if(!v(t))throw Error("Uint8Array expected")}function A(t,e){if("boolean"!=typeof e)throw Error(t+" boolean expected, got "+e)}function x(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function S(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);return""===t?b:BigInt("0x"+t)}const I="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,k=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function P(t){if(B(t),I)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=k[t[r]];return e}const O=48,L=57,T=65,U=70,N=97,R=102;function H(t){return t>=O&&t<=L?t-O:t>=T&&t<=U?t-(T-10):t>=N&&t<=R?t-(N-10):void 0}function q(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);if(I)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,o=0;e<r;e++,o+=2){const r=H(t.charCodeAt(o)),i=H(t.charCodeAt(o+1));if(void 0===r||void 0===i){const e=t[o]+t[o+1];throw Error('hex string expected, got non-hex character "'+e+'" at index '+o)}n[e]=16*r+i}return n}function C(t){return S(P(t))}function D(t){return B(t),S(P(Uint8Array.from(t).reverse()))}function z(t,e){return q(t.toString(16).padStart(2*e,"0"))}function F(t,e){return z(t,e).reverse()}function Z(t,e,r){let n;if("string"==typeof e)try{n=q(e)}catch(e){throw Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!v(e))throw Error(t+" must be hex string or Uint8Array");n=Uint8Array.from(e)}const o=n.length;if("number"==typeof r&&o!==r)throw Error(t+" of length "+r+" expected, got "+o);return n}function j(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];B(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const o=t[e];r.set(o,n),n+=o.length}return r}const V=t=>"bigint"==typeof t&&b<=t;function K(t,e,r){return V(t)&&V(e)&&V(r)&&e<=t&&t<r}function _(t,e,r,n){if(!K(e,r,n))throw Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}const M=t=>(E<<BigInt(t))-E,$=t=>new Uint8Array(t),G=t=>Uint8Array.from(t);const Y={bigint(t){return"bigint"==typeof t},function(t){return"function"==typeof t},boolean(t){return"boolean"==typeof t},string(t){return"string"==typeof t},stringOrUint8Array(t){return"string"==typeof t||v(t)},isSafeInteger(t){return Number.isSafeInteger(t)},array(t){return Array.isArray(t)},field(t,e){return e.Fp.isValid(t)},hash(t){return"function"==typeof t&&Number.isSafeInteger(t.outputLen)}};function W(t,e,r={}){const n=(e,r,n)=>{const o=Y[r];if("function"!=typeof o)throw Error("invalid validator function");const i=t[e];if(!(n&&void 0===i||o(i,t)))throw Error("param "+e+" is invalid. Expected "+r+", got "+i)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}function J(t){const e=new WeakMap;return(r,...n)=>{const o=e.get(r);if(void 0!==o)return o;const i=t(r,...n);return e.set(r,i),i}}const Q=BigInt(0),X=BigInt(1),tt=BigInt(2),et=BigInt(3),rt=BigInt(4),nt=BigInt(5),ot=BigInt(8);function it(t,e){const r=t%e;return r>=Q?r:e+r}function st(t,e,r){if(e<Q)throw Error("invalid exponent, negatives unsupported");if(r<=Q)throw Error("invalid modulus");if(r===X)return Q;let n=X;for(;e>Q;)e&X&&(n=n*t%r),t=t*t%r,e>>=X;return n}function at(t,e,r){let n=t;for(;e-- >Q;)n*=n,n%=r;return n}function ct(t,e){if(t===Q)throw Error("invert: expected non-zero number");if(e<=Q)throw Error("invert: expected positive modulus, got "+e);let r=it(t,e),n=e,o=Q,i=X;for(;r!==Q;){const t=n%r,e=o-i*(n/r);n=r,r=t,o=i,i=e}if(n!==X)throw Error("invert: does not exist");return it(o,e)}function ft(t){if(t%rt===et){const e=(t+X)/rt;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw Error("Cannot find square root");return n}}if(t%ot===nt){const e=(t-nt)/ot;return function(t,r){const n=t.mul(r,tt),o=t.pow(n,e),i=t.mul(r,o),s=t.mul(t.mul(i,tt),o),a=t.mul(i,t.sub(s,t.ONE));if(!t.eql(t.sqr(a),r))throw Error("Cannot find square root");return a}}return function(t){const e=(t-X)/tt;let r,n,o;for(r=t-X,n=0;r%tt===Q;r/=tt,n++);for(o=tt;o<t&&st(o,e,t)!==t-X;o++)if(o>1e3)throw Error("Cannot find square root: likely non-prime P");if(1===n){const e=(t+X)/rt;return(t,r)=>{const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw Error("Cannot find square root");return n}}const i=(r+X)/tt;return(t,s)=>{if(t.pow(s,e)===t.neg(t.ONE))throw Error("Cannot find square root");let a=n,c=t.pow(t.mul(t.ONE,o),r),f=t.pow(s,i),u=t.pow(s,r);for(;!t.eql(u,t.ONE);){if(t.eql(u,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(u);e<a&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(c,X<<BigInt(a-e-1));c=t.sqr(r),f=t.mul(f,r),u=t.mul(u,c),a=e}return f}}(t)}const ut=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function lt(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function dt(t,e,r=!1,n={}){if(t<=Q)throw Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:i}=lt(t,e);if(i>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let s;const a=Object.freeze({ORDER:t,isLE:r,BITS:o,BYTES:i,MASK:M(o),ZERO:Q,ONE:X,create(e){return it(e,t)},isValid(e){if("bigint"!=typeof e)throw Error("invalid field element: expected bigint, got "+typeof e);return Q<=e&&e<t},is0(t){return t===Q},isOdd(t){return(t&X)===X},neg(e){return it(-e,t)},eql(t,e){return t===e},sqr(e){return it(e*e,t)},add(e,r){return it(e+r,t)},sub(e,r){return it(e-r,t)},mul(e,r){return it(e*r,t)},pow(t,e){return function(t,e,r){if(r<Q)throw Error("invalid exponent, negatives unsupported");if(r===Q)return t.ONE;if(r===X)return e;let n=t.ONE,o=e;for(;r>Q;)r&X&&(n=t.mul(n,o)),o=t.sqr(o),r>>=X;return n}(a,t,e)},div(e,r){return it(e*ct(r,t),t)},sqrN(t){return t*t},addN(t,e){return t+e},subN(t,e){return t-e},mulN(t,e){return t*e},inv(e){return ct(e,t)},sqrt:n.sqrt||(e=>(s||(s=ft(t)),s(a,e))),invertBatch(t){return function(t,e){const r=Array(e.length),n=e.reduce(((e,n,o)=>t.is0(n)?e:(r[o]=e,t.mul(e,n))),t.ONE),o=t.inv(n);return e.reduceRight(((e,n,o)=>t.is0(n)?e:(r[o]=t.mul(e,r[o]),t.mul(e,n))),o),r}(a,t)},cmov(t,e,r){return r?e:t},toBytes(t){return r?F(t,i):z(t,i)},fromBytes(t){if(t.length!==i)throw Error("Field.fromBytes: expected "+i+" bytes, got "+t.length);return r?D(t):C(t)}});return Object.freeze(a)}function ht(t){if("bigint"!=typeof t)throw Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function pt(t){const e=ht(t);return e+Math.ceil(e/2)}const gt=BigInt(0),yt=BigInt(1);function mt(t,e){const r=e.negate();return t?r:e}function wt(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw Error("invalid window size, expected [1.."+e+"], got W="+t)}function bt(t,e){wt(t,e);const r=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:M(t),maxNumber:r,shiftBy:BigInt(t)}}function Et(t,e,r){const{windowSize:n,mask:o,maxNumber:i,shiftBy:s}=r;let a=Number(t&o),c=t>>s;a>n&&(a-=i,c+=yt);const f=e*n;return{nextN:c,offset:f+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:e%2!=0,offsetF:f}}const vt=new WeakMap,Bt=new WeakMap;function At(t){return Bt.get(t)||1}function xt(t,e,r,n){if(function(t,e){if(!Array.isArray(t))throw Error("array expected");t.forEach(((t,r)=>{if(!(t instanceof e))throw Error("invalid point at index "+r)}))}(r,t),function(t,e){if(!Array.isArray(t))throw Error("array of scalars expected");t.forEach(((t,r)=>{if(!e.isValid(t))throw Error("invalid scalar at index "+r)}))}(n,e),r.length!==n.length)throw Error("arrays of points and scalars must have equal length");const o=t.ZERO,i=function(t){let e;for(e=0;t>b;t>>=E,e+=1);return e}(BigInt(r.length)),s=i>12?i-3:i>4?i-2:i?2:1,a=M(s),c=Array(Number(a)+1).fill(o);let f=o;for(let t=Math.floor((e.BITS-1)/s)*s;t>=0;t-=s){c.fill(o);for(let e=0;e<n.length;e++){const o=n[e],i=Number(o>>BigInt(t)&a);c[i]=c[i].add(r[e])}let e=o;for(let t=c.length-1,r=o;t>0;t--)r=r.add(c[t]),e=e.add(r);if(f=f.add(e),0!==t)for(let t=0;t<s;t++)f=f.double()}return f}function St(t){return W(t.Fp,ut.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),W(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...lt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function It(t){void 0!==t.lowS&&A("lowS",t.lowS),void 0!==t.prehash&&A("prehash",t.prehash)}const kt={Err:class extends Error{constructor(t=""){super(t)}},_tlv:{encode(t,e){const{Err:r}=kt;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(1&e.length)throw new r("tlv.encode: unpadded data");const n=e.length/2,o=x(n);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const i=n>127?x(o.length/2|128):"";return x(t)+i+o+e},decode(t,e){const{Err:r}=kt;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const o=e[n++];let i=0;if(!!(128&o)){const t=127&o;if(!t)throw new r("tlv.decode(long): indefinite length not supported");if(t>4)throw new r("tlv.decode(long): byte length is too big");const s=e.subarray(n,n+t);if(s.length!==t)throw new r("tlv.decode: length bytes not complete");if(0===s[0])throw new r("tlv.decode(long): zero leftmost byte");for(const t of s)i=i<<8|t;if(n+=t,i<128)throw new r("tlv.decode(long): not minimal encoding")}else i=o;const s=e.subarray(n,n+i);if(s.length!==i)throw new r("tlv.decode: wrong value length");return{v:s,l:e.subarray(n+i)}}},_int:{encode(t){const{Err:e}=kt;if(t<Pt)throw new e("integer: negative integers are not allowed");let r=x(t);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=kt;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return C(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=kt,o=Z("signature",t),{v:i,l:s}=n.decode(48,o);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:f,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(f)}},hexFromSig(t){const{_tlv:e,_int:r}=kt,n=e.encode(2,r.encode(t.r))+e.encode(2,r.encode(t.s));return e.encode(48,n)}},Pt=BigInt(0),Ot=BigInt(1);BigInt(2);const Lt=BigInt(3);function Tt(t){const e=function(t){const e=St(t);W(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:o}=e;if(r){if(!n.eql(o,n.ZERO))throw Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=dt(e.n,e.nBitLength),o=e.toBytes||((t,e)=>{const n=e.toAffine();return j(Uint8Array.from([4]),r.toBytes(n.x),r.toBytes(n.y))}),i=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function s(t){const{a:n,b:o}=e,i=r.sqr(t),s=r.mul(i,t);return r.add(r.add(s,r.mul(t,n)),o)}if(!r.eql(r.sqr(e.Gy),s(e.Gx)))throw Error("bad generator point: equation left != right");function a(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:o,n:i}=e;if(r&&"bigint"!=typeof t){if(v(t)&&(t=P(t)),"string"!=typeof t||!r.includes(t.length))throw Error("invalid private key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:C(Z("private key",t,n))}catch(e){throw Error("invalid private key, expected hex or "+n+" bytes, got "+typeof t)}return o&&(s=it(s,i)),_("private key",s,Ot,i),s}function c(t){if(!(t instanceof l))throw Error("ProjectivePoint expected")}const f=J(((t,e)=>{const{px:n,py:o,pz:i}=t;if(r.eql(i,r.ONE))return{x:n,y:o};const s=t.is0();null==e&&(e=s?r.ONE:r.inv(i));const a=r.mul(n,e),c=r.mul(o,e),f=r.mul(i,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(f,r.ONE))throw Error("invZ was invalid");return{x:a,y:c}})),u=J((t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.py))return;throw Error("bad point: ZERO")}const{x:n,y:o}=t.toAffine();if(!r.isValid(n)||!r.isValid(o))throw Error("bad point: x or y not FE");const i=r.sqr(o),a=s(n);if(!r.eql(i,a))throw Error("bad point: equation left != right");if(!t.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0}));class l{constructor(t,e,n){if(null==t||!r.isValid(t))throw Error("x required");if(null==e||!r.isValid(e))throw Error("y required");if(null==n||!r.isValid(n))throw Error("z required");this.px=t,this.py=e,this.pz=n,Object.freeze(this)}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw Error("invalid affine point");if(t instanceof l)throw Error("projective point not allowed");const o=t=>r.eql(t,r.ZERO);return o(e)&&o(n)?l.ZERO:new l(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(l.fromAffine)}static fromHex(t){const e=l.fromAffine(i(Z("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return l.BASE.multiply(a(t))}static msm(t,e){return xt(l,n,t,e)}_setWindowSize(t){h.setWindowSize(this,t)}assertValidity(){u(this)}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw Error("Field doesn't support isOdd")}equals(t){c(t);const{px:e,py:n,pz:o}=this,{px:i,py:s,pz:a}=t,f=r.eql(r.mul(e,a),r.mul(i,o)),u=r.eql(r.mul(n,a),r.mul(s,o));return f&&u}negate(){return new l(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,o=r.mul(n,Lt),{px:i,py:s,pz:a}=this;let c=r.ZERO,f=r.ZERO,u=r.ZERO,d=r.mul(i,i),h=r.mul(s,s),p=r.mul(a,a),g=r.mul(i,s);return g=r.add(g,g),u=r.mul(i,a),u=r.add(u,u),c=r.mul(t,u),f=r.mul(o,p),f=r.add(c,f),c=r.sub(h,f),f=r.add(h,f),f=r.mul(c,f),c=r.mul(g,c),u=r.mul(o,u),p=r.mul(t,p),g=r.sub(d,p),g=r.mul(t,g),g=r.add(g,u),u=r.add(d,d),d=r.add(u,d),d=r.add(d,p),d=r.mul(d,g),f=r.add(f,d),p=r.mul(s,a),p=r.add(p,p),d=r.mul(p,g),c=r.sub(c,d),u=r.mul(p,h),u=r.add(u,u),u=r.add(u,u),new l(c,f,u)}add(t){c(t);const{px:n,py:o,pz:i}=this,{px:s,py:a,pz:f}=t;let u=r.ZERO,d=r.ZERO,h=r.ZERO;const p=e.a,g=r.mul(e.b,Lt);let y=r.mul(n,s),m=r.mul(o,a),w=r.mul(i,f),b=r.add(n,o),E=r.add(s,a);b=r.mul(b,E),E=r.add(y,m),b=r.sub(b,E),E=r.add(n,i);let v=r.add(s,f);return E=r.mul(E,v),v=r.add(y,w),E=r.sub(E,v),v=r.add(o,i),u=r.add(a,f),v=r.mul(v,u),u=r.add(m,w),v=r.sub(v,u),h=r.mul(p,E),u=r.mul(g,w),h=r.add(u,h),u=r.sub(m,h),h=r.add(m,h),d=r.mul(u,h),m=r.add(y,y),m=r.add(m,y),w=r.mul(p,w),E=r.mul(g,E),m=r.add(m,w),w=r.sub(y,w),w=r.mul(p,w),E=r.add(E,w),y=r.mul(m,E),d=r.add(d,y),y=r.mul(v,E),u=r.mul(b,u),u=r.sub(u,y),y=r.mul(b,m),h=r.mul(v,h),h=r.add(h,y),new l(u,d,h)}subtract(t){return this.add(t.negate())}is0(){return this.equals(l.ZERO)}wNAF(t){return h.wNAFCached(this,t,l.normalizeZ)}multiplyUnsafe(t){const{endo:n,n:o}=e;_("scalar",t,Pt,o);const i=l.ZERO;if(t===Pt)return i;if(this.is0()||t===Ot)return this;if(!n||h.hasPrecomputes(this))return h.wNAFCachedUnsafe(this,t,l.normalizeZ);let{k1neg:s,k1:a,k2neg:c,k2:f}=n.splitScalar(t),u=i,d=i,p=this;for(;a>Pt||f>Pt;)a&Ot&&(u=u.add(p)),f&Ot&&(d=d.add(p)),p=p.double(),a>>=Ot,f>>=Ot;return s&&(u=u.negate()),c&&(d=d.negate()),d=new l(r.mul(d.px,n.beta),d.py,d.pz),u.add(d)}multiply(t){const{endo:n,n:o}=e;let i,s;if(_("scalar",t,Ot,o),n){const{k1neg:e,k1:o,k2neg:a,k2:c}=n.splitScalar(t);let{p:f,f:u}=this.wNAF(o),{p:d,f:p}=this.wNAF(c);f=h.constTimeNegate(e,f),d=h.constTimeNegate(a,d),d=new l(r.mul(d.px,n.beta),d.py,d.pz),i=f.add(d),s=u.add(p)}else{const{p:e,f:r}=this.wNAF(t);i=e,s=r}return l.normalizeZ([i,s])[0]}multiplyAndAddUnsafe(t,e,r){const n=l.BASE,o=(t,e)=>e!==Pt&&e!==Ot&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,r));return i.is0()?void 0:i}toAffine(t){return f(this,t)}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Ot)return!0;if(r)return r(l,this);throw Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Ot?this:r?r(l,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return A("isCompressed",t),this.assertValidity(),o(l,this,t)}toHex(t=!0){return A("isCompressed",t),P(this.toRawBytes(t))}}l.BASE=new l(e.Gx,e.Gy,r.ONE),l.ZERO=new l(r.ZERO,r.ONE,r.ZERO);const d=e.nBitLength,h=(p=l,g=e.endo?Math.ceil(d/2):d,{constTimeNegate:mt,hasPrecomputes:t=>1!==At(t),unsafeLadder(t,e,r=p.ZERO){let n=t;for(;e>gt;)e&yt&&(r=r.add(n)),n=n.double(),e>>=yt;return r},precomputeWindow(t,e){const{windows:r,windowSize:n}=bt(e,g),o=[];let i=t,s=i;for(let t=0;t<r;t++){s=i,o.push(s);for(let t=1;t<n;t++)s=s.add(i),o.push(s);i=s.double()}return o},wNAF(t,e,r){let n=p.ZERO,o=p.BASE;const i=bt(t,g);for(let t=0;t<i.windows;t++){const{nextN:s,offset:a,isZero:c,isNeg:f,isNegF:u,offsetF:l}=Et(r,t,i);r=s,c?o=o.add(mt(u,e[l])):n=n.add(mt(f,e[a]))}return{p:n,f:o}},wNAFUnsafe(t,e,r,n=p.ZERO){const o=bt(t,g);for(let t=0;t<o.windows&&r!==gt;t++){const{nextN:i,offset:s,isZero:a,isNeg:c}=Et(r,t,o);if(r=i,!a){const t=e[s];n=n.add(c?t.negate():t)}}return n},getPrecomputes(t,e,r){let n=vt.get(e);return n||(n=this.precomputeWindow(e,t),1!==t&&vt.set(e,r(n))),n},wNAFCached(t,e,r){const n=At(t);return this.wNAF(n,this.getPrecomputes(n,t,r),e)},wNAFCachedUnsafe(t,e,r,n){const o=At(t);return 1===o?this.unsafeLadder(t,e,n):this.wNAFUnsafe(o,this.getPrecomputes(o,t,r),e,n)},setWindowSize(t,e){wt(e,g),Bt.set(t,e),vt.delete(t)}});var p,g;return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:a,weierstrassEquation:s,isWithinCurveOrder(t){return K(t,Ot,e.n)}}}function Ut(t){const e=function(t){const e=St(t);return W(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n}=e,o=r.BYTES+1,i=2*r.BYTES+1;function s(t){return it(t,n)}function a(t){return ct(t,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:f,weierstrassEquation:u,isWithinCurveOrder:l}=Tt({...e,toBytes(t,e,n){const o=e.toAffine(),i=r.toBytes(o.x),s=j;return A("isCompressed",n),n?s(Uint8Array.from([e.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,r.toBytes(o.y))},fromBytes(t){const e=t.length,n=t[0],s=t.subarray(1);if(e!==o||2!==n&&3!==n){if(e===i&&4===n){return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))}}throw Error("invalid Point, expected length of "+o+", or uncompressed "+i+", got "+e)}{const t=C(s);if(!K(t,Ot,r.ORDER))throw Error("Point is not on curve");const e=u(t);let o;try{o=r.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw Error("Point is not on curve"+e)}return!(1&~n)!==((o&Ot)===Ot)&&(o=r.neg(o)),{x:t,y:o}}}}),d=t=>P(z(t,e.nByteLength));function h(t){return t>n>>Ot}const p=(t,e,r)=>C(t.slice(e,r));class g{constructor(t,e,r){_("r",t,Ot,n),_("s",e,Ot,n),this.r=t,this.s=e,null!=r&&(this.recovery=r),Object.freeze(this)}static fromCompact(t){const r=e.nByteLength;return t=Z("compactSignature",t,2*r),new g(p(t,0,r),p(t,r,2*r))}static fromDER(t){const{r:e,s:r}=kt.toSig(Z("DER",t));return new g(e,r)}assertValidity(){}addRecoveryBit(t){return new g(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:o,recovery:i}=this,f=b(Z("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw Error("recovery id invalid");const u=2===i||3===i?n+e.n:n;if(u>=r.ORDER)throw Error("recovery id 2 or 3 invalid");const l=1&i?"03":"02",h=c.fromHex(l+d(u)),p=a(u),g=s(-f*p),y=s(o*p),m=c.BASE.multiplyAndAddUnsafe(h,g,y);if(!m)throw Error("point at infinify");return m.assertValidity(),m}hasHighS(){return h(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return q(this.toDERHex())}toDERHex(){return kt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return q(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const y={isValidPrivateKey(t){try{return f(t),!0}catch(t){return!1}},normPrivateKeyToScalar:f,randomPrivateKey(){const t=pt(e.n);return function(t,e,r=!1){const n=t.length,o=ht(e),i=pt(e);if(n<16||n<i||n>1024)throw Error("expected "+i+"-1024 bytes of input, got "+n);const s=it(r?D(t):C(t),e-X)+X;return r?F(s,o):z(s,o)}(e.randomBytes(t),e.n)},precompute:(t=8,e=c.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function m(t){const e=v(t),r="string"==typeof t,n=(e||r)&&t.length;return e?n===o||n===i:r?n===2*o||n===2*i:t instanceof c}const w=e.bits2int||(t=>{if(t.length>8192)throw Error("input is too large");const r=C(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r}),b=e.bits2int_modN||(t=>s(w(t))),E=M(e.nBitLength);function B(t){return _("num < 2^"+e.nBitLength,t,Pt,E),z(t,e.nByteLength)}function x(t,n,o=S){if(["recovered","canonical"].some((t=>t in o)))throw Error("sign() legacy options not supported");const{hash:i,randomBytes:u}=e;let{lowS:d,prehash:p,extraEntropy:y}=o;null==d&&(d=!0),t=Z("msgHash",t),It(o),p&&(t=Z("prehashed msgHash",i(t)));const m=b(t),E=f(n),v=[B(E),B(m)];if(null!=y&&!1!==y){const t=!0===y?u(r.BYTES):y;v.push(Z("extraEntropy",t))}const A=j(...v),x=m;return{seed:A,k2sig(t){const e=w(t);if(!l(e))return;const r=a(e),n=c.BASE.multiply(e).toAffine(),o=s(n.x);if(o===Pt)return;const i=s(r*s(x+o*E));if(i===Pt)return;let f=(n.x===o?0:2)|Number(n.y&Ot),u=i;return d&&h(i)&&(u=function(t){return h(t)?s(-t):t}(i),f^=1),new g(o,u,f)}}}const S={lowS:e.lowS,prehash:!1},I={lowS:e.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:e,getPublicKey(t,e=!0){return c.fromPrivateKey(t).toRawBytes(e)},getSharedSecret(t,e,r=!0){if(m(t))throw Error("first arg must be private key");if(!m(e))throw Error("second arg must be public key");return c.fromHex(e).multiply(f(t)).toRawBytes(r)},sign(t,r,n=S){const{seed:o,k2sig:i}=x(t,r,n),s=e;return function(t,e,r){if("number"!=typeof t||t<2)throw Error("hashLen must be a number");if("number"!=typeof e||e<2)throw Error("qByteLen must be a number");if("function"!=typeof r)throw Error("hmacFn must be a function");let n=$(t),o=$(t),i=0;const s=()=>{n.fill(1),o.fill(0),i=0},a=(...t)=>r(o,n,...t),c=(t=$(0))=>{o=a(G([0]),t),n=a(),0!==t.length&&(o=a(G([1]),t),n=a())},f=()=>{if(i++>=1e3)throw Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=a();const e=n.slice();r.push(e),t+=n.length}return j(...r)};return(t,e)=>{let r;for(s(),c(t);!(r=e(f()));)c();return s(),r}}(s.hash.outputLen,s.nByteLength,s.hmac)(o,i)},verify(t,r,n,o=I){const i=t;r=Z("msgHash",r),n=Z("publicKey",n);const{lowS:f,prehash:u,format:l}=o;if(It(o),"strict"in o)throw Error("options.strict was renamed to lowS");if(void 0!==l&&"compact"!==l&&"der"!==l)throw Error("format must be compact or der");const d="string"==typeof i||v(i),h=!d&&!l&&"object"==typeof i&&null!==i&&"bigint"==typeof i.r&&"bigint"==typeof i.s;if(!d&&!h)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");let p,y;try{if(h&&(p=new g(i.r,i.s)),d){try{"compact"!==l&&(p=g.fromDER(i))}catch(t){if(!(t instanceof kt.Err))throw t}p||"der"===l||(p=g.fromCompact(i))}y=c.fromHex(n)}catch(t){return!1}if(!p)return!1;if(f&&p.hasHighS())return!1;u&&(r=e.hash(r));const{r:m,s:w}=p,E=b(r),B=a(w),A=s(E*B),x=s(m*B),S=c.BASE.multiplyAndAddUnsafe(y,A,x)?.toAffine();return!!S&&s(S.x)===m},ProjectivePoint:c,Signature:g,utils:y}}function Nt(t){return{hash:t,hmac(r,...n){return w(t,r,function(...t){let r=0;for(let n=0;n<t.length;n++){const o=t[n];e(o),r+=o.length}const n=new Uint8Array(r);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}(...n))},randomBytes:f}}BigInt(4);const Rt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ht=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),qt=BigInt(1),Ct=BigInt(2),Dt=(t,e)=>(t+e/Ct)/e;function zt(t){const e=Rt,r=BigInt(3),n=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),f=t*t*t%e,u=f*f*t%e,l=at(u,r,e)*u%e,d=at(l,r,e)*u%e,h=at(d,Ct,e)*f%e,p=at(h,o,e)*h%e,g=at(p,i,e)*p%e,y=at(g,a,e)*g%e,m=at(y,c,e)*y%e,w=at(m,a,e)*g%e,b=at(w,r,e)*u%e,E=at(b,s,e)*p%e,v=at(E,n,e)*f%e,B=at(v,Ct,e);if(!Ft.eql(Ft.sqr(B),t))throw Error("Cannot find square root");return B}const Ft=dt(Rt,void 0,void 0,{sqrt:zt}),Zt=function(t,e){const r=e=>Ut({...t,...Nt(e)});return{...r(e),create:r}}({a:BigInt(0),b:BigInt(7),Fp:Ft,n:Ht,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(t){const e=Ht,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-qt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,s=BigInt("0x100000000000000000000000000000000"),a=Dt(i*t,e),c=Dt(-n*t,e);let f=it(t-a*r-c*o,e),u=it(-a*n-c*i,e);const l=f>s,d=u>s;if(l&&(f=e-f),d&&(u=e-u),f>s||u>s)throw Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:f,k2neg:d,k2:u}}}},y),jt=BigInt(0),Vt={};function Kt(t,...e){let r=Vt[t];if(void 0===r){const e=y(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=j(e,e),Vt[t]=r}return y(j(r,...e))}const _t=t=>t.toRawBytes(!0).slice(1),Mt=t=>z(t,32),$t=t=>it(t,Rt),Gt=t=>it(t,Ht),Yt=Zt.ProjectivePoint;function Wt(t){let e=Zt.utils.normPrivateKeyToScalar(t),r=Yt.fromPrivateKey(e);return{scalar:r.hasEvenY()?e:Gt(-e),bytes:_t(r)}}function Jt(t){_("x",t,qt,Rt);const e=$t(t*t);let r=zt($t(e*t+BigInt(7)));r%Ct!==jt&&(r=$t(-r));const n=new Yt(t,r,qt);return n.assertValidity(),n}const Qt=C;function Xt(...t){return Gt(Qt(Kt("BIP0340/challenge",...t)))}function te(t){return Wt(t).bytes}function ee(t,e,r=f(32)){const n=Z("message",t),{bytes:o,scalar:i}=Wt(e),s=Z("auxRand",r,32),a=Mt(i^Qt(Kt("BIP0340/aux",s))),c=Kt("BIP0340/nonce",a,o,n),u=Gt(Qt(c));if(u===jt)throw Error("sign failed: k is zero");const{bytes:l,scalar:d}=Wt(u),h=Xt(l,o,n),p=new Uint8Array(64);if(p.set(l,0),p.set(Mt(Gt(d+h*i)),32),!re(p,n,o))throw Error("sign: Invalid signature produced");return p}function re(t,e,r){const n=Z("signature",t,64),o=Z("message",e),i=Z("publicKey",r,32);try{const t=Jt(Qt(i)),e=Qt(n.subarray(0,32));if(!K(e,qt,Rt))return!1;const r=Qt(n.subarray(32,64));if(!K(r,qt,Ht))return!1;const f=Xt(Mt(e),_t(t),o),u=(s=t,a=r,c=Gt(-f),Yt.BASE.multiplyAndAddUnsafe(s,a,c));return!(!u||!u.hasEvenY()||u.toAffine().x!==e)}catch(t){return!1}var s,a,c}const ne=(()=>({getPublicKey:te,sign:ee,verify:re,utils:{randomPrivateKey:Zt.utils.randomPrivateKey,lift_x:Jt,pointToBytes:_t,numberToBytesBE:z,bytesToNumberBE:C,taggedHash:Kt,mod:it}}))(),{floor:oe,random:ie,sin:se}=Math,ae="Trystero",ce=(t,e)=>Array(t).fill().map(e),fe="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",ue=t=>ce(t,(()=>fe[oe(62*ie())])).join(""),le=ue(20),de=Promise.all.bind(Promise),he="undefined"!=typeof window,{entries:pe,fromEntries:ge,keys:ye}=Object,me=()=>{},we=t=>Error(`${ae}: ${t}`),be=new TextEncoder,Ee=new TextDecoder,ve=t=>be.encode(t),Be=t=>Ee.decode(t),Ae=t=>t.reduce(((t,e)=>t+e.toString(16).padStart(2,"0")),""),xe=(...t)=>t.join("@"),Se=(t,e,r)=>(t.relayUrls||((t,e)=>{const r=[...t],n=()=>{const t=1e4*se(e++);return t-oe(t)};let o=r.length;for(;o;){const t=oe(n()*o--);[r[o],r[t]]=[r[t],r[o]]}return r})(e,Pe(t.appId))).slice(0,t.relayUrls?t.relayUrls.length:t.relayRedundancy||r),Ie=JSON.stringify,ke=JSON.parse,Pe=(t,e=Number.MAX_SAFE_INTEGER)=>t.split("").reduce(((t,e)=>t+e.charCodeAt(0)),0)%e,Oe={},Le="AES-GCM",Te={},Ue=async t=>Te[t]||(Te[t]=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",ve(t)))).map((t=>t.toString(36))).join("")),Ne=async(t,e)=>{const r=crypto.getRandomValues(new Uint8Array(16));return r.join(",")+"$"+(n=await crypto.subtle.encrypt({name:Le,iv:r},await t,ve(e)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))));var n},Re=async(t,e)=>{const[r,n]=e.split("$");return Be(await crypto.subtle.decrypt({name:Le,iv:new Uint8Array(r.split(","))},await t,(t=>{const e=atob(t);return new Uint8Array(e.length).map(((t,r)=>e.charCodeAt(r))).buffer})(n)))},He="icegatheringstatechange",qe=t=>t.replace(/a=ice-options:trickle\s\n/g,"");var Ce=(t,{rtcConfig:e,rtcPolyfill:r,turnConfig:n})=>{const o=new(r||RTCPeerConnection)({iceServers:De.concat(n||[]),...e}),i={},s=t=>{t.binaryType="arraybuffer",t.bufferedAmountLowThreshold=65535,t.onmessage=t=>i.data?.(t.data),t.onopen=()=>i.connect?.(),t.onclose=()=>i.close?.(),t.onerror=t=>i.error?.(t)},a=async t=>{if(!t.localDescription)throw Error("No local description available");return await Promise.race([new Promise((e=>{const r=()=>{if(!t.canTrickleIceCandidates)return t.removeEventListener(He,r),void e();"complete"===t.iceGatheringState&&(t.removeEventListener(He,r),e())};t.addEventListener(He,r),r()})),new Promise((t=>setTimeout(t,5e3)))]),{type:t.localDescription.type,sdp:qe(t.localDescription.sdp)}};let c=!1,f=null,u=!1;return t?(f=o.createDataChannel("data"),s(f)):o.ondatachannel=({channel:t})=>{f=t,s(t)},o.onnegotiationneeded=async()=>{try{c=!0,await o.setLocalDescription();const t=await a(o);i.signal?.({type:t.type,sdp:qe(t.sdp)})}catch(t){i.error?.(t)}finally{c=!1}},o.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(o.connectionState)&&i.close?.()},o.ontrack=t=>{i.track?.(t.track,t.streams[0]),i.stream?.(t.streams[0])},o.onremovestream=t=>{i.stream?.(t.stream,{removed:!0})},t&&(o.canTrickleIceCandidates||o.onnegotiationneeded()),{created:Date.now(),connection:o,get channel(){return f},get isDead(){return"closed"===o.connectionState},async signal(e){if("open"!==f?.readyState)try{if("offer"===e.type){if((c||"stable"!==o.signalingState)&&(u=!t,u))return;await o.setRemoteDescription(e),await o.setLocalDescription();const r=await a(o),n=qe(r.sdp);return i.signal?.({type:r.type,sdp:n}),{type:r.type,sdp:n}}"answer"!==e.type||"have-local-offer"!==o.signalingState&&"have-remote-offer"!==o.signalingState||await o.setRemoteDescription(e)}catch(t){i.error?.(t)}else if(("offer"===e.type||"stable"!==o.signalingState)&&(await o.setRemoteDescription(e),"offer"===e.type)){await o.setLocalDescription();const t=await a(o);return i.signal?.({type:t.type,sdp:t.sdp}),{type:t.type,sdp:t.sdp}}},sendData(t){return f.send(t)},destroy(){f&&f.close(),o.close()},setHandlers(t){return Object.assign(i,t)},offerPromise:t?new Promise((t=>{i.signal=e=>{"offer"===e.type&&t(e)}})):Promise.resolve(),addStream(t){t.getTracks().forEach((e=>o.addTrack(e,t)))},removeStream(t){o.getSenders().filter((e=>t.getTracks().includes(e.track))).forEach((t=>o.removeTrack(t)))},addTrack(t,e){return o.addTrack(t,e)},removeTrack(t){const e=o.getSenders().find((e=>e.track===t));e&&o.removeTrack(e)},async replaceTrack(t,e){const r=o.getSenders().find((e=>e.track===t));r&&await r.replaceTrack(e)}}};const De=[...ce(3,((t,e)=>`stun:stun${e||""}.l.google.com:19302`)),"stun:global.stun.twilio.com:3478"].map((t=>({urls:t}))),ze=Object.getPrototypeOf(Uint8Array),Fe=16369,Ze=255,je="bufferedamountlow",Ve=t=>"@_"+t;const Ke={},_e="EVENT",Me=ne.utils.randomPrivateKey(),$e=Ae(ne.getPublicKey(Me)),Ge={},Ye={},We={},Je=()=>Math.floor(Date.now()/1e3),Qe=t=>We[t]??=Pe(t,1e4)+2e4,Xe=async(t,e)=>{const r={kind:Qe(t),content:e,pubkey:$e,created_at:Je(),tags:[["x",t]]},n=Ae(new Uint8Array(await crypto.subtle.digest("SHA-256",ve(Ie([0,r.pubkey,r.created_at,r.kind,r.tags,r.content])))));return Ie([_e,{...r,id:n,sig:Ae(await ne.sign(n,Me))}])},tr=(t,e)=>(Ge[t]=e,Ie(["REQ",t,{kinds:[Qe(e)],since:Je(),"#x":[e]}])),er=t=>(delete Ge[t],Ie(["CLOSE",t])),rr=(({init:t,subscribe:e,announce:r})=>{const n={};let o,i,s,a=!1;return(c,f,u)=>{const{appId:l}=c;if(n[l]?.[f])return n[l][f];const d={},h={},p=xe(ae,l,f),g=Ue(p),y=Ue(xe(p,le)),m=(async(t,e,r)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},ve(`${t}:${e}:${r}`)),{name:Le},!1,["encrypt","decrypt"]))(c.password||"",l,f),w=t=>async e=>({type:e.type,sdp:await t(m,e.sdp)}),b=w(Re),E=w(Ne),v=()=>Ce(!0,c),B=(t,e,r)=>{h[e]?h[e]!==t&&t.destroy():(h[e]=t,L(t,e),d[e]?.forEach(((t,e)=>{e!==r&&t.destroy()})),delete d[e])},A=(t,e)=>{h[e]===t&&delete h[e]},x=t=>(i.push(...ce(t,v)),de(i.splice(0,t).map((t=>t.offerPromise.then(E).then((e=>({peer:t,offer:e}))))))),S=(t,e)=>u?.({error:`incorrect password (${c.password}) when decrypting ${e}`,appId:l,peerId:t,roomId:f}),I=t=>async(e,r,n)=>{const[o,i]=await de([g,y]);if(e!==o&&e!==i)return;const{peerId:s,offer:a,answer:f,peer:u}="string"==typeof r?ke(r):r;if(s!==le&&!h[s])if(!s||a||f){if(a){const e=d[s]?.[t];if(e&&le>s)return;const r=Ce(!1,c);let o;r.setHandlers({connect(){return B(r,s,t)},close(){return A(r,s)}});try{o=await b(a)}catch{return void S(s,"offer")}if(r.isDead)return;const[i,f]=await de([Ue(xe(p,s)),r.signal(o)]);n(i,Ie({peerId:le,answer:await E(f)}))}else if(f){let e;try{e=await b(f)}catch(t){return void S(s,"answer")}if(u)u.setHandlers({connect(){return B(u,s,t)},close(){return A(u,s)}}),u.signal(e);else{const r=d[s]?.[t];r&&!r.isDead&&r.signal(e)}}}else{if(d[s]?.[t])return;const[[{peer:e,offer:r}],o]=await de([x(1),Ue(xe(p,s))]);d[s]||=[],d[s][t]=e,setTimeout((()=>((t,e)=>{if(h[t])return;const r=d[t]?.[e];r&&(delete d[t][e],r.destroy())})(s,t)),.9*k[t]),e.setHandlers({connect(){return B(e,s,t)},close(){return A(e,s)}}),n(o,Ie({peerId:le,offer:r}))}};if(!c)throw we("requires a config map as the first argument");if(!l&&!c.firebaseApp)throw we("config map is missing appId field");if(!f)throw we("roomId argument required");if(!a){const e=t(c);i=ce(20,v),o=Array.isArray(e)?e:[e],a=!0,s=setInterval((()=>i=i.filter((t=>{const e=Date.now()-t.created<57333;return e||t.destroy(),e}))),59052.99)}const k=o.map((()=>5333)),P=[],O=o.map((async(t,r)=>e(await t,await g,await y,I(r),x)));de([g,y]).then((([t,e])=>{const n=async(o,i)=>{const s=await r(o,t,e);"number"==typeof s&&(k[i]=s),P[i]=setTimeout((()=>n(o,i)),k[i])};O.forEach((async(t,e)=>{await t,n(await o[e],e)}))}));let L=me;return n[l]||={},n[l][f]=((t,e,r)=>{const n={},o={},i={},s={},a={},c={},f={},u={onPeerJoin:me,onPeerLeave:me,onPeerStream:me,onPeerTrack:me},l=(t,e)=>(t?Array.isArray(t)?t:[t]:ye(n)).flatMap((t=>{const r=n[t];return r?e(t,r):(console.warn(`${ae}: no peer with id ${t} found`),[])})),d=t=>{n[t]&&(delete n[t],delete s[t],delete a[t],u.onPeerLeave(t),e(t))},h=t=>{if(o[t])return i[t];if(!t)throw we("action type argument is required");const e=ve(t);if(e.byteLength>12)throw we(`action type string "${t}" (${e.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const r=new Uint8Array(12);r.set(e);let s=0;return o[t]={onComplete:me,onProgress:me,setOnComplete:e=>o[t]={...o[t],onComplete:e},setOnProgress:e=>o[t]={...o[t],onProgress:e},async send(t,e,o,i){if(o&&"object"!=typeof o)throw we("action meta argument must be an object");const a=typeof t;if("undefined"===a)throw we("action data cannot be undefined");const c="string"!==a,f=t instanceof Blob,u=f||t instanceof ArrayBuffer||t instanceof ze;if(o&&!u)throw we("action meta argument can only be used with binary data");const d=u?new Uint8Array(f?await t.arrayBuffer():t):ve(c?Ie(t):t),h=o?ve(Ie(o)):null,p=Math.ceil(d.byteLength/Fe)+(o?1:0)||1,g=ce(p,((t,e)=>{const n=e===p-1,i=o&&0===e,a=new Uint8Array(15+(i?h.byteLength:n?d.byteLength-Fe*(p-(o?2:1)):Fe));return a.set(r),a.set([s],12),a.set([n|i<<1|u<<2|c<<3],13),a.set([Math.round((e+1)/p*Ze)],14),a.set(o?i?h:d.subarray((e-1)*Fe,e*Fe):d.subarray(e*Fe,(e+1)*Fe),15),a}));return s=s+1&Ze,de(l(e,(async(t,e)=>{const{channel:r}=e;let s=0;for(;s<p;){const a=g[s];if(r.bufferedAmount>r.bufferedAmountLowThreshold&&await new Promise((t=>{const e=()=>{r.removeEventListener(je,e),t()};r.addEventListener(je,e)})),!n[t])break;e.sendData(a),s++,i?.(a[14]/Ze,t,o)}})))}},i[t]||=[o[t].send,o[t].setOnComplete,o[t].setOnProgress]},p=(t,e)=>{const r=new Uint8Array(e),n=Be(r.subarray(0,12)).replaceAll("\0",""),[i]=r.subarray(12,13),[a]=r.subarray(13,14),[c]=r.subarray(14,15),f=r.subarray(15),u=!!(1&a),l=!!(2&a),d=!!(4&a),h=!!(8&a);if(!o[n])return void console.warn(`${ae}: received message with unregistered type (${n})`);s[t]||={},s[t][n]||={};const p=s[t][n][i]||={chunks:[]};if(l?p.meta=ke(Be(f)):p.chunks.push(f),o[n].onProgress(c/Ze,t,p.meta),!u)return;const g=new Uint8Array(p.chunks.reduce(((t,e)=>t+e.byteLength),0));if(p.chunks.reduce(((t,e)=>(g.set(e,t),t+e.byteLength)),0),delete s[t][n][i],d)o[n].onComplete(g,t,p.meta);else{const e=Be(g);o[n].onComplete(h?ke(e):e,t)}},g=async()=>{await I(""),await new Promise((t=>setTimeout(t,99))),pe(n).forEach((([t,e])=>{e.destroy(),delete n[t]})),r()},[y,m]=h(Ve("ping")),[w,b]=h(Ve("pong")),[E,v]=h(Ve("signal")),[B,A]=h(Ve("stream")),[x,S]=h(Ve("track")),[I,k]=h(Ve("leave"));return t(((t,e)=>{n[e]||(n[e]=t,t.setHandlers({data:t=>p(e,t),stream(t){u.onPeerStream(t,e,c[e]),delete c[e]},track(t,r){u.onPeerTrack(t,r,e,f[e]),delete f[e]},signal:t=>E(t,e),close:()=>d(e),error:()=>d(e)}),u.onPeerJoin(e),t.drainEarlyData?.((t=>p(e,t))))})),m(((t,e)=>w("",e))),b(((t,e)=>{a[e]?.(),delete a[e]})),v(((t,e)=>n[e]?.signal(t))),A(((t,e)=>c[e]=t)),S(((t,e)=>f[e]=t)),k(((t,e)=>d(e))),he&&addEventListener("beforeunload",g),{makeAction:h,leave:g,async ping(t){if(!t)throw we("ping() must be called with target peer ID");const e=Date.now();return y("",t),await new Promise((e=>a[t]=e)),Date.now()-e},getPeers:()=>ge(pe(n).map((([t,e])=>[t,e.connection]))),addStream:(t,e,r)=>l(e,(async(e,n)=>{r&&await B(r,e),n.addStream(t)})),removeStream:(t,e)=>l(e,((e,r)=>r.removeStream(t))),addTrack:(t,e,r,n)=>l(r,(async(r,o)=>{n&&await x(n,r),o.addTrack(t,e)})),removeTrack:(t,e,r)=>l(r,((r,n)=>n.removeTrack(t,e))),replaceTrack:(t,e,r,n,o)=>l(n,(async(n,i)=>{o&&await x(o,n),i.replaceTrack(t,e,r)})),onPeerJoin:t=>u.onPeerJoin=t,onPeerLeave:t=>u.onPeerLeave=t,onPeerStream:t=>u.onPeerStream=t,onPeerTrack:t=>u.onPeerTrack=t}})((t=>L=t),(t=>delete h[t]),(()=>{delete n[l][f],P.forEach(clearTimeout),O.forEach((async t=>(await t)())),clearInterval(s)}))}})({init(t){return Se(t,ir,5).map((t=>{const e=((t,e)=>{const r={},n=()=>{const o=new WebSocket(t);o.onclose=()=>{Oe[t]??=3333,setTimeout(n,Oe[t]),Oe[t]*=2},o.onmessage=t=>e(t.data),r.socket=o,r.url=o.url,r.ready=new Promise((e=>o.onopen=()=>{e(r),Oe[t]=3333})),r.send=t=>{1===o.readyState&&o.send(t)}};return n(),r})(t,(t=>{const[r,n,o,i]=ke(t);if(r===_e)Ye[n]?.(Ge[n],o.content);else{const t=`${ae}: relay failure from ${e.url} - `;"NOTICE"===r?console.warn(t+n):"OK"!==r||o||console.warn(t+i)}}));return Ke[t]=e,e.ready}))},subscribe(t,e,r,n){const o=ue(64),i=ue(64);return Ye[o]=Ye[i]=(e,r)=>n(e,r,(async(e,r)=>t.send(await Xe(e,r)))),t.send(tr(o,e)),t.send(tr(i,r)),()=>{t.send(er(o)),t.send(er(i)),delete Ye[o],delete Ye[i]}},async announce(t,e){return t.send(await Xe(e,Ie({peerId:le})))}}),nr=(or=Ke,()=>ge(pe(or).map((([t,e])=>[t,e.socket]))));var or;const ir=["eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","multiplexer.huszonegy.world","nostr.cool110.xyz","nostr.data.haus","nostr.grooveix.com","nostr.huszonegy.world","nostr.mom","nostr.sathoarder.com","nostr.vulpem.com","relay.fountain.fm","relay.nostraddress.com","relay.nostromo.social","relay.snort.social","relay.verified-nostr.com","yabu.me/v2"].map((t=>"wss://"+t));export{ir as defaultRelayUrls,nr as getRelaySockets,rr as joinRoom,le as selfId};